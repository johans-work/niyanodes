<p align=center>
</br>
<img src="https://github.com/johans-work/niyanodes/assets/108384802/8db06b17-19a3-4a30-b5ac-0ebb34114648">
</br>
</p>

## tldr

niya = each node is an instance of a type in a tree


## overview

Niya nodes is a new tool for abstraction oriented programing focused on abstracting, implementing, and utilizing anything that can be abstracted and implemented by the user. 

Any time you have nodes that progressively lead to more nodes, you inevitably get a tree. Your file system is essentially a node tree, and so is the web. But in both cases, the user is confined to the abstractions of each system. But what if you could combine those trees? What if you could add a uniform layer that describes and accesses each tree? What if everything is just another node? A computational canvas for everything, where you go to add what's necessary, and get to do all that is possible. 

Adding a layer adds work, so much like digitizing analog, nodalizing better be worth it. Digitizing introduced perfect copies and perfect data. Nodalizing gives a piece of data a name, type, and location. But data is but one type of common abstraction found in computational systems. We also have code, hardware, and software. And through software, we have databases, servers, communications, and the internet.



## node & type basics

Each node is an abstraction that has a name, implementation, and address. A name is any fitting string of letters. An implementation is anything that a computer can remember or access. And an address is just the names of its parent nodes in order. Users build their nodes and trees, then use and share them. Or, "noding" for short.

When two nodes have something in common, we can create a template for that type of node. This makes every node an instance of a type. And that's the last piece of the basic niya node spec. If a node has been done before, you just copy it, and fill in the blanks. 

In nature, almost everything is unique. Each fingerprint, each moment in time, and each cake you bake. At the same time, almost everything has something in common. Being a fingerprint, being a moment in time, and being a cake. And we would say, every fingerprint is an instance of the fingerprint type. In niya, every node is an instance of the node type, or "type node", if not also something else.

It's important to distinguish between a real fingerprint and the word "fingerprint". The word is used to describe every fingerprint, but is not a fingerprint itself. Each fingerprint is still unique. It's a fingerprint, but also something more. For starters, it's real. It then may be yours, and so on. But what isn't unique is the word "fingerprint" and how we can casually throw it around. "Fingerprint" is the abstraction, and niya is a system for creating and managing abstractions. As software, niya can interact with its host's hardware, and hence the real world. This is where your abstractions hit the metal, and become real.

## implementation basics

Like a todo list has elements that make it a todo list, niya nodes just has elements that make it a niya node tree. As such, niya itself is just an abstraction in need of an implementation, and is implementation agnostic. Choose the type that works best for you, or build your own. 

The elements:

##


Computer objects have it both ways. The abstractions themselves become real.


Similar to what digital does for analog, nodal will do for digital.




##

We've caught on to the value of meta data. This is the meta system.

Just as an abstract of a paper is a smaller pattern that describes a larger pattern, so are all words in Enlgish that represent their meaning, and names of people that represent each person. The names form a name space that allows us to differentiate each abstraction individually.

It's abstraction, abstracted. 

The app is being built at [nod.ing](http://nod.ing/).

, and not nodejs, or anything specific in networking.

For more on abstraction see _____.





