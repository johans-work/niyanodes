<p align=center>
</br>
<img src="https://github.com/johans-work/niyanodes/assets/108384802/8db06b17-19a3-4a30-b5ac-0ebb34114648">
</br>
</p>

## tldr

niya = each node is an instance of a type in a tree

Abstraction, abstracted.
A pure abstraction layer.

## overview

Niya (knee-uh) is a new framework for abstraction oriented programming focused on the highest level of abstraction we can represent in machines - abstraction itself. The one perfectly physical thing that is both empty and everything at the same time. Niya is abstraction abstracted.



Nodes that spawn more nodes inevitably create trees. Your file system, the web, even web pages are essentially node trees. But systems are always confined to their own abstractions. What if you could combine those trees to where everything is just another node? A computational canvas where you  add what's necessary and do what's implemented. 

Adding a layer adds work that must be worth it. Digitizing gave data perfect copies. Nodalizing gives data an identity and home, with every node being extensible, interoperable, and adaptable. If data turned everything into 0s and 1s, nodalizing turns everything into things that grow on trees and talk.

Data is just one abstraction found in your computer. There's also code, hardware, and even the internet. But why would we end there? 

Before any screen, abstraction starts with the moment you're concsious. Your mind is an evolved abstraction machine, and you experience a pre-abstracted reality through the lens of the language you were born into. Most abstractions are already known, just waiting to be implemented, not invented. 

Abstractions offer the smallest unit of reason, not just in computers, but in your brain, and extend to the rest of the world, and become that world. Most software is not about the machine. Accounting software is about accounting, and graphics software is about graphics. Only coding is really about computers, but even then, we're coding accounting software for accountants, implementing the abstractions that already exist in the accounting world, so that computers can reason with them. 

Programming has always been abstraction oriented, and abstractions have never been confined to the machine. 



## abstract positivism



## said Alan Kay

disclaimer: Heavy confirmation bias. 

"Water was not discovered by a fish."

"Data and processes already split the computer in half."

The more you add, the more marginalized abstractions become. But if you don't add anything, you have nothing. Only the potential of anything.

But even "computer" was split and left something behind. The least split abstraction is, abstraction. And the greatest first split is between type and instance. The thing itself, and what the thing is of.

"It takes more complicated building blocks to simplify things."

Every node being an instance of a type. It doesn't get any simpler. But do you truly understand abstraction? It could be one of the most sophisticated and valuable concepts you learn in your life.


## node & type basics

Each node is an abstraction that has a name, implementation, and address. A name is any fitting string of letters. An implementation is anything that a computer can remember or access. And an address is just the names of its parent nodes in order. Users build their nodes and trees, then use and share them. Or, "noding" for short.

When two nodes have something in common, we can create a template for that type of node. This makes every node an instance of a type. Or, "typing" for short.

In nature, almost everything is unique. Each fingerprint, each moment in time, and each cake you bake. At the same time, almost everything has something in common. Being a fingerprint, being a moment in time, and being a cake. And we would say, every fingerprint is an instance of the fingerprint type. In niya, every node is an instance of the node type, or "type node", if not also something else.

It's important to distinguish between a real fingerprint and the word "fingerprint". The word is used to describe every fingerprint, but is not a fingerprint itself. Each fingerprint is still unique. It's a fingerprint, but also something more. For starters, it's real. It then may be yours, and so on. But what isn't unique is the word "fingerprint" and how we can casually throw it around. "Fingerprint" is the abstraction, and niya is a system for creating and managing abstractions. As software, niya can interact with its host's hardware, and hence the real world. This is where your abstractions hit the metal, and become real.

## implementation basics

A todo list has what makes it a todo list, and is implementation agnostic. It could be an app, in html or drawn on paper. Similarly, niya nodes is also just an abstraction seeking an implementation. All you need is to know how it works. 

If you have nodes, that form a tree, that are categorized by type, you have a niya node tree.

The HTML Recipe:

niya = each node is an instance of a type in a tree  

- structure
  - instance tree: empty user nodes
  - type tree: range of types available
  - system tree: an instance of a niya implementation
- functions
  - display tree
  - display node
  - add node (seed)
  - edit node
  - generate instance from type
  - generate type from instance
  - copy & paste
  - import / export
- optional features
  - ledger tree
  - inbox / outbox trees
  - configuration tree
  - documentation


## noding basics

Whether you are building a new tree or converting something that already exists, the steps are the same.

1. Install niya nodes. 
2. Start with a seed and name it what it is.
3. Independent parts make siblings.
4. Dependent parts make children.
5. Add documentation and implementation nodes.

##

<!--

Computer objects have it both ways. The abstractions themselves become real.


Similar to what digital does for analog, nodal will do for digital.


Abstraction is not about hiding or inaccessibility or security.
Abstraction is about independence, fault tolerance (forgiveness), and minding your own business.

No one needs to say anything if all is known.

this is  you telling it
node.do()

within a node
node.do()
this is the node telling it.


abstractions exclude the moment they are created
and are created with the purpose of exclusion

##

We've caught on to the value of meta data. This is the meta system.

Just as an abstract of a paper is a smaller pattern that describes a larger pattern, so are all words in Enlgish that represent their meaning, and names of people that represent each person. The names form a name space that allows us to differentiate each abstraction individually.

It's abstraction, abstracted. 

The app is being built at [nod.ing](http://nod.ing/).

, and not nodejs, or anything specific in networking.

For more on abstraction see _____.

Portable and independent. 

Two copies make a type.

Niya node test.
What qualifies as a node tree? 
Is it a tree? Are the nodes instances of types?

only as do

if there is a preset order, don't contradict it

is as do
abstract over do, to get is.

competition
collaboration
build a team
each member is independent

indepentent and portable
can be copied perfectly, can it travel, can it become a message.

abstractions can be copied within the expression space.

keep everything explicit. 
PUT does this but POST does this because PUT is this and POST is that.
form submit no repeat
ajax should be ajax
let should be let

let html

expressions are agreed upon
conventions standards rules
if the expression is bad, change it
make it different or make it the same
utility will determine the correctness of that choice



is is bad, except = is is. 
if image // jpeg =
the comparison
determine if same
determine if copy

the problem with comparing abstractions
the expression could be anything
it's a layer on top of what the actual thing is
be it the actual implementation, or the thing it's representing
the expression could be anything


, optimized for abstracting, implementing, and utilizing abstractions, and in that order.

You say, but it has five fingers, to which I say, but it's made of clay.


