<p align=center>
</br>
<img src="https://github.com/johans-work/niyanodes/assets/108384802/8db06b17-19a3-4a30-b5ac-0ebb34114648">
</br>
</p>

## tldr

niya = each node is an instance of a type in a tree


## overview

Niya nodes is a new framework for abstraction oriented programming, optimized for abstracting, implementing, and utilizing abstractions, and in that order.

Any time you have nodes that progressively lead to more nodes, you inevitably get a tree. Your file system is essentially a node tree, and so is the web. But in both cases, the user is confined to the abstractions of each system. But what if you could combine those trees? What if you could add a uniform layer that describes and accesses each tree? What if everything is just another node? A computational canvas for everything, where you go to add what's necessary, and get to do all that is made possible by every individual implementation. 

Adding a layer adds work, so much like digitizing analog, nodalizing better be worth it. Digitizing introduced perfect copies and perfect data. Nodalizing gives a piece of data a name, type, and location. But data is but one type of common abstraction found in your computer. You also have code, software, hardware, and even the internet. But it doesn't end there.

Before any screen, abstraction starts with the moment you're awake. Your mind is an abstraction machine, and you experience a pre-abstracted reality based on the language you were born into. Most abstractions are already known, just waiting to be implemented, not invented. 

Abstractions offer the smallest unit of reason, and not just computer abstractions, but of the world. Most software is not about the machine. Accounting software is about accounting, and graphics software is about graphics. Only coding is really about computers, but even then, we're coding accounting software for accountants, implementing the abstractions that already exist in the accounting world, so that computers can reason with them. 

Programming has always been abstraction oriented, and abstractions have never been confined to the machine.

## why now?


## abstraction theory



## the theory of positivity



## said Alan Kay

"Data and processes already split the computer in half."

The more you add, the more marginalized abstractions becomes. But if you don't add anything, you have nothing. Only the potential of anything.

"It takes more complicated building blocks to simplify things."

Every node being an instance of a type. It doesn't get any simpler. 


## node & type basics

Each node is an abstraction that has a name, implementation, and address. A name is any fitting string of letters. An implementation is anything that a computer can remember or access. And an address is just the names of its parent nodes in order. Users build their nodes and trees, then use and share them. Or, "noding" for short.

When two nodes have something in common, we can create a template for that type of node. This makes every node an instance of a type. Or, "typing" for short.

In nature, almost everything is unique. Each fingerprint, each moment in time, and each cake you bake. At the same time, almost everything has something in common. Being a fingerprint, being a moment in time, and being a cake. And we would say, every fingerprint is an instance of the fingerprint type. In niya, every node is an instance of the node type, or "type node", if not also something else.

It's important to distinguish between a real fingerprint and the word "fingerprint". The word is used to describe every fingerprint, but is not a fingerprint itself. Each fingerprint is still unique. It's a fingerprint, but also something more. For starters, it's real. It then may be yours, and so on. But what isn't unique is the word "fingerprint" and how we can casually throw it around. "Fingerprint" is the abstraction, and niya is a system for creating and managing abstractions. As software, niya can interact with its host's hardware, and hence the real world. This is where your abstractions hit the metal, and become real.

## implementation basics

Like a todo list has elements that make it a todo list, niya nodes just has elements that make it a niya node tree. As such, niya itself is just an abstraction in need of an implementation, and is implementation agnostic. Choose the type that works best for you, or build your own. 

The elements:

##


Computer objects have it both ways. The abstractions themselves become real.


Similar to what digital does for analog, nodal will do for digital.




##

We've caught on to the value of meta data. This is the meta system.

Just as an abstract of a paper is a smaller pattern that describes a larger pattern, so are all words in Enlgish that represent their meaning, and names of people that represent each person. The names form a name space that allows us to differentiate each abstraction individually.

It's abstraction, abstracted. 

The app is being built at [nod.ing](http://nod.ing/).

, and not nodejs, or anything specific in networking.

For more on abstraction see _____.





