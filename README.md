<p align=center>
</br>
<img src="https://github.com/johans-work/niyanodes/assets/108384802/8db06b17-19a3-4a30-b5ac-0ebb34114648">
</br>
</p>

## tldr

niya = each node is an instance of a type in a tree

Abstraction, abstracted.

## overview

Niya (knee-uh) is a new framework for abstraction oriented programming, optimized for abstracting, implementing, and utilizing abstractions, and in that order.

Nodes that spawn more nodes inevitably create trees. Your file system, the web, even web pages are essentially node trees. But systems are always confined to their own abstractions. What if you could combine those trees to where everything is just another node? A computational canvas where you  add what's necessary and do what's implemented. 

Adding a layer adds work that must be worth it. Digitizing gave data perfect copies. Nodalizing gives data an identity and home, with every node being extensible, interoperable, and adaptable. If data turned everything into 0s and 1s, nodalizing turns everything into things that grow on trees and talk.

Data is just one abstraction found in your computer. There's also code, hardware, and even the internet. But why would we end there? 

Before any screen, abstraction starts with the moment you're concsious. Your mind is an evolved abstraction machine, and you experience a pre-abstracted reality through the lens of the language you were born into. Most abstractions are already known, just waiting to be implemented, not invented. 

Abstractions offer the smallest unit of reason, not just in computers, but in your brain, and extend to the rest of the world. Most software is not about the machine. Accounting software is about accounting, and graphics software is about graphics. Only coding is really about computers, but even then, we're coding accounting software for accountants, implementing the abstractions that already exist in the accounting world, so that computers can reason with them. 

Programming has always been abstraction oriented, and abstractions have never been confined to the machine. 

Niya is the first tool focused on the highest level of abstraction we can represent in machines - abstraction itself. 

Niya is abstraction abstracted.

## abstract positivism



## said Alan Kay

"Water was not discovered by a fish."

"Data and processes already split the computer in half."

The more you add, the more marginalized abstractions become. But if you don't add anything, you have nothing. Only the potential of anything.

But even "computer" was split and left something behind. The least split abstraction is, abstraction. And the greatest first split is between type and instance. The thing itself, and what the thing is of.

"It takes more complicated building blocks to simplify things."

Every node being an instance of a type. It doesn't get any simpler. 


## node & type basics

Each node is an abstraction that has a name, implementation, and address. A name is any fitting string of letters. An implementation is anything that a computer can remember or access. And an address is just the names of its parent nodes in order. Users build their nodes and trees, then use and share them. Or, "noding" for short.

When two nodes have something in common, we can create a template for that type of node. This makes every node an instance of a type. Or, "typing" for short.

In nature, almost everything is unique. Each fingerprint, each moment in time, and each cake you bake. At the same time, almost everything has something in common. Being a fingerprint, being a moment in time, and being a cake. And we would say, every fingerprint is an instance of the fingerprint type. In niya, every node is an instance of the node type, or "type node", if not also something else.

It's important to distinguish between a real fingerprint and the word "fingerprint". The word is used to describe every fingerprint, but is not a fingerprint itself. Each fingerprint is still unique. It's a fingerprint, but also something more. For starters, it's real. It then may be yours, and so on. But what isn't unique is the word "fingerprint" and how we can casually throw it around. "Fingerprint" is the abstraction, and niya is a system for creating and managing abstractions. As software, niya can interact with its host's hardware, and hence the real world. This is where your abstractions hit the metal, and become real.

## implementation basics

A todo list has what makes it a todo list, and is implementation agnostic. It could be an app, in html or drawn on paper. Similarly, niya nodes is also just an abstraction seeking an implementation. All you need is to know how it works.

The Recipe:

niya = each node is an instance of a type in a tree  

- structure
  - instance tree: empty user nodes
  - type tree: range of types available
  - system tree: an instance of a niya implementation
- functions
  - display tree
  - display node
  - edit node
  - create instance from type
  - generate type from instance
  - copy & paste
- optional features
  - ledger tree
  - inbox / outbox trees
  - configuration tree

##


Computer objects have it both ways. The abstractions themselves become real.


Similar to what digital does for analog, nodal will do for digital.




##

We've caught on to the value of meta data. This is the meta system.

Just as an abstract of a paper is a smaller pattern that describes a larger pattern, so are all words in Enlgish that represent their meaning, and names of people that represent each person. The names form a name space that allows us to differentiate each abstraction individually.

It's abstraction, abstracted. 

The app is being built at [nod.ing](http://nod.ing/).

, and not nodejs, or anything specific in networking.

For more on abstraction see _____.





