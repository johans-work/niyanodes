<p align=center>
</br>
<img src="https://github.com/johans-work/niyanodes/assets/108384802/8db06b17-19a3-4a30-b5ac-0ebb34114648">
</br>
</p>

## tldr

niya = each node is an instance of a type in a tree

The highest abstraction layer, and a blank computational canvas for everything.

Abstraction, abstracted.

## overview

Niya (knee-uh) nodes is a new framework for abstraction oriented programming, optimized for abstracting, implementing, and utilizing abstractions, and in that order.

Any time you have nodes that progressively lead to more nodes, you inevitably get a tree. Your file system is essentially a node tree, and so is the web. But in both cases, the user is confined to the abstractions of each system. But what if you could combine those trees? What if you could add a uniform layer that describes and accesses each tree? What if everything is just another node? A computational canvas for everything, where you go to add what's necessary, and get to do all that is made possible by every individual implementation. 

Adding a layer adds work that better be worth it. Digitizing gave data perfect copies. Nodalizing gives data an identity and location. If data turned everything into 0s and 1s, nodalizing turns everything into "things".

Yet, data is just one abstraction found in your computer. There's code, software, hardware, and even the internet. But why would it end there? Before any screen, abstraction starts with the moment you're concsious. Your mind is an abstraction machine, and you experience a pre-abstracted reality based on the language you were born into. Most abstractions are already known, just waiting to be implemented, not invented. 

Abstractions offer the smallest unit of reason, and not just computer abstractions, but of the world. Most software is not about the machine. Accounting software is about accounting, and graphics software is about graphics. Only coding is really about computers, but even then, we're coding accounting software for accountants, implementing the abstractions that already exist in the accounting world, so that computers can reason with them. 

Programming has always been abstraction oriented, and abstractions have never been confined to the machine. 

Niya is the first tool focused on the highest level of abstraction we can represent in a machine - abstraction itself. 

## abstract positivism



## said Alan Kay

"Water was not discovered by a fish."

"Data and processes already split the computer in half."

The more you add, the more marginalized abstractions become. But if you don't add anything, you have nothing. Only the potential of anything.

But even "computer" was split and left something behind. The least split abstraction is, abstraction. And the greatest first split is between type and instance. The thing itself, and what the thing is of.

"It takes more complicated building blocks to simplify things."

Every node being an instance of a type. It doesn't get any simpler. 


## node & type basics

Each node is an abstraction that has a name, implementation, and address. A name is any fitting string of letters. An implementation is anything that a computer can remember or access. And an address is just the names of its parent nodes in order. Users build their nodes and trees, then use and share them. Or, "noding" for short.

When two nodes have something in common, we can create a template for that type of node. This makes every node an instance of a type. Or, "typing" for short.

In nature, almost everything is unique. Each fingerprint, each moment in time, and each cake you bake. At the same time, almost everything has something in common. Being a fingerprint, being a moment in time, and being a cake. And we would say, every fingerprint is an instance of the fingerprint type. In niya, every node is an instance of the node type, or "type node", if not also something else.

It's important to distinguish between a real fingerprint and the word "fingerprint". The word is used to describe every fingerprint, but is not a fingerprint itself. Each fingerprint is still unique. It's a fingerprint, but also something more. For starters, it's real. It then may be yours, and so on. But what isn't unique is the word "fingerprint" and how we can casually throw it around. "Fingerprint" is the abstraction, and niya is a system for creating and managing abstractions. As software, niya can interact with its host's hardware, and hence the real world. This is where your abstractions hit the metal, and become real.

## implementation basics

Like a todo list has elements that make it a todo list, niya nodes just has elements that make it a niya node tree. As such, niya itself is just an abstraction in need of an implementation, and is implementation agnostic. Choose the type that works best for you, or build your own. 

- structure
  - instance tree
  - type tree
  - ledger (optional)
  - inbox / outbox (optional)
- features
  - create instance
  - generate type from instance
  - display node
  - edit node



##


Computer objects have it both ways. The abstractions themselves become real.


Similar to what digital does for analog, nodal will do for digital.




##

We've caught on to the value of meta data. This is the meta system.

Just as an abstract of a paper is a smaller pattern that describes a larger pattern, so are all words in Enlgish that represent their meaning, and names of people that represent each person. The names form a name space that allows us to differentiate each abstraction individually.

It's abstraction, abstracted. 

The app is being built at [nod.ing](http://nod.ing/).

, and not nodejs, or anything specific in networking.

For more on abstraction see _____.





